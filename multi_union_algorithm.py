# -*- coding: utf-8 -*-

"""
/***************************************************************************
 MultiUnionAlgorithm
                                 A QGIS plugin
 This plugin runs the UNION tool, allowing you to use up to 6 vector polygon layers simultaneously.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-11-11
        copyright            : (C) 2023 by Antonio Sobral Almeida
        email                : 66124.almeida@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Antonio Sobral Almeida'
__date__ = '2023-11-11'
__copyright__ = '(C) 2023 by Antonio Sobral Almeida'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import QgsProcessing
from qgis.core import QgsProcessingAlgorithm
from qgis.core import QgsProcessingMultiStepFeedback
from qgis.core import QgsProcessingParameterVectorLayer
from qgis.core import QgsProcessingParameterField
from qgis.core import QgsProcessingParameterFeatureSink
from qgis.core import QgsProcessingParameterDefinition
import processing


class MultiUnionAlgorithm(QgsProcessingAlgorithm):

    def initAlgorithm(self, config=None):

        param = QgsProcessingParameterField('input_polygon_1_fields', 'Input polygon 1 fields', type=QgsProcessingParameterField.Any, parentLayerParameterName='input_polygon_vector_1', allowMultiple=True, defaultValue=None, defaultToAllFields=True)
        param.setFlags(param.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        self.addParameter(param)
        param = QgsProcessingParameterField('input_polygon_2_fields', 'Input polygon 2 fields', type=QgsProcessingParameterField.Any, parentLayerParameterName='input_polygon_vector_2', allowMultiple=True, defaultValue=None, defaultToAllFields=True)
        param.setFlags(param.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        self.addParameter(param)
        param = QgsProcessingParameterField('input_polygon_3_fields', 'Input polygon 3 fields', type=QgsProcessingParameterField.Any, parentLayerParameterName='input_polygon_vector_3', allowMultiple=True, defaultValue=None, defaultToAllFields=True)
        param.setFlags(param.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        self.addParameter(param)
        param = QgsProcessingParameterField('input_polygon_4_fields', 'Input polygon 4 fields', optional=True, type=QgsProcessingParameterField.Any, parentLayerParameterName='input_polygon_vector_4', allowMultiple=True, defaultValue=None, defaultToAllFields=True)
        param.setFlags(param.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        self.addParameter(param)
        param = QgsProcessingParameterField('input_polygon_5_fields', 'Input polygon 5 fields', optional=True, type=QgsProcessingParameterField.Any, parentLayerParameterName='input_polygon_vector_5', allowMultiple=True, defaultValue=None, defaultToAllFields=True)
        param.setFlags(param.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        self.addParameter(param)
        param = QgsProcessingParameterField('input_polygon_6_fields', 'Input polygon 6 fields', optional=True, type=QgsProcessingParameterField.Any, parentLayerParameterName='input_polygon_vector_6', allowMultiple=True, defaultValue=None, defaultToAllFields=True)
        param.setFlags(param.flags() | QgsProcessingParameterDefinition.FlagAdvanced)
        self.addParameter(param)
        self.addParameter(QgsProcessingParameterVectorLayer('input_polygon_vector_1', 'Input polygon vector 1 [mandatory]', types=[QgsProcessing.TypeVectorPolygon], defaultValue=None))
        self.addParameter(QgsProcessingParameterVectorLayer('input_polygon_vector_2', 'Input polygon vector 2 [mandatory]', types=[QgsProcessing.TypeVectorPolygon], defaultValue=None))        
        self.addParameter(QgsProcessingParameterVectorLayer('input_polygon_vector_3', 'Input polygon vector 3 [mandatory]', types=[QgsProcessing.TypeVectorPolygon], defaultValue=None))
        self.addParameter(QgsProcessingParameterVectorLayer('input_polygon_vector_4', 'Input polygon vector 4', optional=True, types=[QgsProcessing.TypeVectorPolygon], defaultValue=None))
        self.addParameter(QgsProcessingParameterVectorLayer('input_polygon_vector_5', 'Input polygon vector 5', optional=True, types=[QgsProcessing.TypeVectorPolygon], defaultValue=None))
        self.addParameter(QgsProcessingParameterVectorLayer('input_polygon_vector_6', 'Input polygon vector 6', optional=True, types=[QgsProcessing.TypeVectorPolygon], defaultValue=None))
        self.addParameter(QgsProcessingParameterFeatureSink('MultiUnionResult', 'Multi-union Result', type=QgsProcessing.TypeVectorAnyGeometry, createByDefault=True, defaultValue=None))

    def processAlgorithm(self, parameters, context, model_feedback):
        # Use a multi-step feedback, so that individual child algorithm progress reports are adjusted for the
        # overall progress through the model
        feedback = QgsProcessingMultiStepFeedback(13, model_feedback)
        results = {}
        outputs = {}

#************************************************   Tratamento dos inputs obrigatorios   **********************************************************

        Overlay = []
        # Retain fields 1
        alg_params = {
            'FIELDS': parameters['input_polygon_1_fields'],
            'INPUT': parameters['input_polygon_vector_1'],
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['RetainFields1'] = processing.run('native:retainfields', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(1)
        if feedback.isCanceled():
            return {}

        # Retain fields 2
        alg_params = {
            'FIELDS': parameters['input_polygon_2_fields'],
            'INPUT': parameters['input_polygon_vector_2'],
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['RetainFields2'] = processing.run('native:retainfields', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(2)
        if feedback.isCanceled():
            return {}

        # Fix geometries 1
        alg_params = {
            'INPUT': outputs['RetainFields1']['OUTPUT'],
            'METHOD': 1,  # Structure
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['FixGeometries1'] = processing.run('native:fixgeometries', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(3)
        if feedback.isCanceled():
            return {}

        # Fix geometries 2
        alg_params = {
            'INPUT': outputs['RetainFields2']['OUTPUT'],
            'METHOD': 1,  # Structure
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['FixGeometries2'] = processing.run('native:fixgeometries', alg_params, context=context, feedback=feedback, is_child_algorithm=True)
        Overlay.append(outputs['FixGeometries2']['OUTPUT'])
        feedback.setCurrentStep(4)
        if feedback.isCanceled():
            return {}

        # Retain fields 3
        alg_params = {
            'FIELDS': parameters['input_polygon_3_fields'],
            'INPUT': parameters['input_polygon_vector_3'],
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['RetainFields3'] = processing.run('native:retainfields', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

        feedback.setCurrentStep(5)
        if feedback.isCanceled():
            return {}

        # Fix geometries 3
        alg_params = {
            'INPUT': outputs['RetainFields3']['OUTPUT'],
            'METHOD': 1,  # Structure
            'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
        }
        outputs['FixGeometries3'] = processing.run('native:fixgeometries', alg_params, context=context, feedback=feedback, is_child_algorithm=True)
        Overlay.append(outputs['FixGeometries3']['OUTPUT'])
        feedback.setCurrentStep(6)
        if feedback.isCanceled():
            return {}


#***************************************************   Tratamento dos inputs opcionais   **********************************************************

        if (parameters['input_polygon_vector_4']):

            # Retain fields 4
            alg_params = {
                'FIELDS': parameters['input_polygon_4_fields'],
                'INPUT': parameters['input_polygon_vector_4'],
                'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
            }
            outputs['RetainFields4'] = processing.run('native:retainfields', alg_params, context=context, feedback=feedback, is_child_algorithm=True)

            feedback.setCurrentStep(7)
            if feedback.isCanceled():
                return {}

            # Fix geometries 4
            alg_params = {
                'INPUT': outputs['RetainFields4']['OUTPUT'],
                'METHOD': 1,  # Structure
                'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
            }
            outputs['FixGeometries4'] = processing.run('native:fixgeometries', alg_params, context=context, feedback=feedback, is_child_algorithm=True)
            Overlay.append(outputs['FixGeometries4']['OUTPUT'])
            feedback.setCurrentStep(8)
            if feedback.isCanceled():
                return {}

        if (parameters['input_polygon_vector_5']):

            # Retain fields 5
            alg_params = {
                'FIELDS': parameters['input_polygon_5_fields'],
                'INPUT': parameters['input_polygon_vector_5'],
                'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
            }
            outputs['RetainFields5'] = processing.run('native:retainfields', alg_params, context=context, feedback=feedback, is_child_algorithm=True)
           
            feedback.setCurrentStep(9)
            if feedback.isCanceled():
                return {}

            # Fix geometries 5
            alg_params = {
                'INPUT': outputs['RetainFields5']['OUTPUT'],
                'METHOD': 1,  # Structure
                'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
            }
            outputs['FixGeometries5'] = processing.run('native:fixgeometries', alg_params, context=context, feedback=feedback, is_child_algorithm=True)
            Overlay.append(outputs['FixGeometries5']['OUTPUT'])
            feedback.setCurrentStep(10)
            if feedback.isCanceled():
                return {}

        if (parameters['input_polygon_vector_6']):

            # Retain fields 6
            alg_params = {
                'FIELDS': parameters['input_polygon_6_fields'],
                'INPUT': parameters['input_polygon_vector_6'],
                'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
            }
            outputs['RetainFields6'] = processing.run('native:retainfields', alg_params, context=context, feedback=feedback, is_child_algorithm=True)
           
            feedback.setCurrentStep(11)
            if feedback.isCanceled():
                return {}

            # Fix geometries 6
            alg_params = {
                'INPUT': outputs['RetainFields6']['OUTPUT'],
                'METHOD': 1,  # Structure
                'OUTPUT': QgsProcessing.TEMPORARY_OUTPUT
            }
            outputs['FixGeometries6'] = processing.run('native:fixgeometries', alg_params, context=context, feedback=feedback, is_child_algorithm=True)
            Overlay.append(outputs['FixGeometries6']['OUTPUT'])
            feedback.setCurrentStep(12)
            if feedback.isCanceled():
                return {}

        # Union (multiple)

        alg_params = {
            'INPUT': outputs['FixGeometries1']['OUTPUT'],
            'OVERLAYS': Overlay[:],
            'OVERLAY_FIELDS_PREFIX': '',
            'OUTPUT': parameters['MultiUnionResult']
        }
        outputs['UnionMultiple'] = processing.run('native:multiunion', alg_params, context=context, feedback=feedback, is_child_algorithm=True)
        results['MultiUnionResult'] = outputs['UnionMultiple']['OUTPUT']
        return results

    def tr(self, string):
        """
        Returns areas, perimeters and lengths of polygon and line vector layers.
        """
        return QCoreApplication.translate('Processing', string)

    def name(self):
        return 'Multi-Union'

    def displayName(self):
        return 'Multi-Union V 0.1'

    def group(self):
        return None

    def groupId(self):
        return None

    def shortHelpString(self):
        return self.tr("This plugin performs a similar operation to the UNION tool available in the Vector -> Geoprocessing Tools menu of QGis3, but in this tool it is only possible to use two layers at a time, while in the MULTI-UNION plugin it is possible to use up to 6 layers in a single operation. Being a multiple union, the minimum number of layers is 3 layers, which must be placed in Inputs 1, 2 and 3. Optionally, 3 more layers can be used, in Inputs 4, 5 and 6. Expand the Advanced Parameters tab to choose which fields of each input layers will be included in the resulting UNION layer. Up to six layers can be used, in which case features from each layer are split at their overlap with features from the others, creating a layer (Union layer) containing all the portions from all layers. The attribute table of the Union layer is filled with attribute values from the respective original layers for non-overlapping features, and attribute values from all layers for overlapping features.")

    def createInstance(self):
        return MultiUnionAlgorithm()
